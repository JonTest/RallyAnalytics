// Generated by CoffeeScript 1.4.0
(function() {
  var TIPVisualizer, lumenize, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  utils = lumenize.utils;

  TIPVisualizer = (function(_super) {

    __extends(TIPVisualizer, _super);

    function TIPVisualizer() {
      this.onNewDataAvailable = __bind(this.onNewDataAvailable, this);
      return TIPVisualizer.__super__.constructor.apply(this, arguments);
    }

    /*
    */


    TIPVisualizer.prototype.initialize = function() {
      var field, s, trackLastValueForTheseFields, _i, _len, _ref, _ref1;
      if (this.config.trace) {
        console.log('in TIPVisualizer.initialize');
      }
      TIPVisualizer.__super__.initialize.call(this);
      this.config.toolTipFieldNames = [];
      _ref = this.config.showTheseFieldsInToolTip;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (utils.type(s) === 'string') {
          field = s;
        } else {
          field = s.field;
        }
        this.config.toolTipFieldNames.push(field);
      }
      trackLastValueForTheseFields = ['_ValidTo'].concat(this.config.toolTipFieldNames);
      if (_ref1 = this.config.radiusField.field, __indexOf.call(trackLastValueForTheseFields, _ref1) < 0) {
        trackLastValueForTheseFields.push(this.config.radiusField.field);
      }
      this.config.lumenizeCalculatorConfig.trackLastValueForTheseFields = trackLastValueForTheseFields;
      this.config.lumenizeCalculatorConfig.granularity = 'hour';
      this.config.lumenizeCalculatorConfig.workDayStartOn = this.config.workDayStartOn;
      this.config.lumenizeCalculatorConfig.workDayEndBefore = this.config.workDayEndBefore;
      this.config.lumenizeCalculatorConfig.holidays = this.config.holidays;
      this.config.lumenizeCalculatorConfig.workDays = this.config.workDays;
      return this.LumenizeCalculatorClass = lumenize.TimeInStateCalculator;
    };

    TIPVisualizer.prototype.onNewDataAvailable = function() {
      var queryConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.onNewDataAvailable');
      }
      queryConfig = {
        'X-RallyIntegrationName': 'TIP Chart (prototype)',
        'X-RallyIntegrationVendor': 'Rally Red Pill',
        'X-RallyIntegrationVersion': '0.2.0',
        workspaceOID: this.projectAndWorkspaceScope.workspaceOID
      };
      if (this.upToDateISOString == null) {
        this.upToDateISOString = '2011-12-01T00:00:00.000Z';
      }
      this.analyticsQuery = new TimeInStateAnalyticsQuery(queryConfig, this.upToDateISOString, this.config.statePredicate);
      if (this.projectAndWorkspaceScope.projectScopingUp) {
        if (this.config.debug) {
          console.log('Project scoping up. OIDs in scope: ', this.projectAndWorkspaceScope.projectOIDsInScope);
        }
        this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOIDsInScope);
      } else if (this.projectAndWorkspaceScope.projectScopingDown) {
        if (this.config.debug) {
          console.log('Project scoping down. Setting _ProjectHierarchy to: ', this.projectAndWorkspaceScope.projectOID);
        }
        this.analyticsQuery.scope('_ProjectHierarchy', this.projectAndWorkspaceScope.projectOID);
      } else {
        if (this.config.debug) {
          console.log('Project with no up or down scoping. Setting Project to: ', this.projectAndWorkspaceScope.projectOID);
        }
        this.analyticsQuery.scope('Project', this.projectAndWorkspaceScope.projectOID);
      }
      this.analyticsQuery.type(this.config.type).fields(this.config.toolTipFieldNames);
      if (this.config.leafOnly) {
        this.analyticsQuery.leafOnly();
      }
      if (this.config.asOf != null) {
        this.analyticsQuery.additionalCriteria({
          _ValidFrom: {
            $lt: this.getAsOfISOString()
          }
        });
      }
      if (this.config.debug) {
        this.analyticsQuery.debug();
        console.log('Requesting data...');
      }
      this.fetchPending = true;
      return this.analyticsQuery.getPage(this.onSnapshotsReceieved);
    };

    TIPVisualizer.prototype.getHashForCache = function() {
      var hashObject, hashString, out, salt, userConfig;
      if (this.config.trace) {
        console.log('in TIPVisualizer.getHashForCache');
      }
      hashObject = {};
      userConfig = utils.clone(this.userConfig);
      delete userConfig.debug;
      delete userConfig.trace;
      delete userConfig.daysToShow;
      delete userConfig.showStillInProgress;
      hashObject.userConfig = userConfig;
      hashObject.projectAndWorkspaceScope = this.projectAndWorkspaceScope;
      hashObject.workspaceConfiguration = this.workspaceConfiguration;
      salt = 'TIP v0.2.95';
      hashString = JSON.stringify(hashObject);
      out = md5(hashString + salt);
      return out;
    };

    TIPVisualizer.prototype.updateVisualizationData = function() {
      var asOfMilliseconds, b, bucketSize, buckets, calculatorResults, chartMax, clipped, endBeforeInMinutes, histogramCategories, histogramData, histogramResults, inProcessItems, jsDateMilliseconds, millisecondsToShow, notInProcessItems, row, series, startMilliseconds, startOnInMinutes, valueMax, workHours, workMinutes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
      if (this.config.trace) {
        console.log('in TIPVisualizer.updateVisualizationData');
      }
      calculatorResults = this.lumenizeCalculator.getResults();
      if (calculatorResults.length === 0) {
        if (this.config.debug) {
          console.log('No calculatorResults.');
        }
        if (this.fetchPending) {
          if (this.config.debug) {
            console.log('fetchPending is true so returning with visualizationData = null.');
          }
          this.visualizationData = null;
          return;
        } else {
          series = [];
          if (this.config.debug) {
            console.log('fetchPending is false so filling in with blanks');
          }
        }
      } else {
        this.virgin = false;
        inProcessItems = [];
        notInProcessItems = [];
        if (this.config.asOf != null) {
          asOfMilliseconds = new lumenize.Time(this.config.asOf, 'millisecond', this.config.lumenizeCalculatorConfig.tz).getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
        } else {
          asOfMilliseconds = new Date().getTime();
        }
        millisecondsToShow = this.userConfig.daysToShow * 1000 * 60 * 60 * 24;
        startMilliseconds = asOfMilliseconds - millisecondsToShow;
        for (_i = 0, _len = calculatorResults.length; _i < _len; _i++) {
          row = calculatorResults[_i];
          jsDateMilliseconds = new lumenize.Time(row._ValidTo_lastValue, 'millisecond', this.config.lumenizeCalculatorConfig.tz).getJSDate(this.config.lumenizeCalculatorConfig.tz).getTime();
          if (jsDateMilliseconds > asOfMilliseconds) {
            row.x = asOfMilliseconds;
          } else {
            row.x = jsDateMilliseconds;
          }
          row.x -= Math.random() * 1000 * 60 * 60 * 24;
          if (this.config.radiusField != null) {
            row.marker = {
              radius: this.config.radiusField.f(row[this.config.radiusField.field + "_lastValue"])
            };
          }
          if (jsDateMilliseconds > startMilliseconds) {
            if (jsDateMilliseconds < asOfMilliseconds) {
              notInProcessItems.push(row);
            } else {
              inProcessItems.push(row);
            }
          }
        }
        startOnInMinutes = this.config.workDayStartOn.hour * 60;
        if ((_ref = this.config.workDayStartOn) != null ? _ref.minute : void 0) {
          startOnInMinutes += this.config.workDayStartOn.minute;
        }
        endBeforeInMinutes = this.config.workDayEndBefore.hour * 60;
        if ((_ref1 = this.config.workDayEndBefore) != null ? _ref1.minute : void 0) {
          endBeforeInMinutes += this.config.workDayEndBefore.minute;
        }
        if (startOnInMinutes < endBeforeInMinutes) {
          workMinutes = endBeforeInMinutes - startOnInMinutes;
        } else {
          workMinutes = 24 * 60 - startOnInMinutes;
          workMinutes += endBeforeInMinutes;
        }
        workHours = workMinutes / 60;
        for (_j = 0, _len1 = inProcessItems.length; _j < _len1; _j++) {
          row = inProcessItems[_j];
          row.days = row.ticks / workHours;
        }
        for (_k = 0, _len2 = notInProcessItems.length; _k < _len2; _k++) {
          row = notInProcessItems[_k];
          row.days = row.ticks / workHours;
        }
      }
      histogramResults = lumenize.histogram(notInProcessItems, 'days');
      if (histogramResults == null) {
        if (this.config.debug) {
          console.log('No histogramResults. Returning.');
        }
        return;
      }
      buckets = histogramResults.buckets, chartMax = histogramResults.chartMax, valueMax = histogramResults.valueMax, bucketSize = histogramResults.bucketSize, clipped = histogramResults.clipped;
      for (_l = 0, _len3 = notInProcessItems.length; _l < _len3; _l++) {
        row = notInProcessItems[_l];
        row.y = row.clippedChartValue;
      }
      for (_m = 0, _len4 = inProcessItems.length; _m < _len4; _m++) {
        row = inProcessItems[_m];
        if (row.days > chartMax) {
          row.y = chartMax;
        } else {
          row.y = row.days;
        }
      }
      histogramCategories = [];
      histogramData = [];
      for (_n = 0, _len5 = buckets.length; _n < _len5; _n++) {
        b = buckets[_n];
        histogramCategories.push(b.label);
        histogramData.push(b.count);
      }
      series = [
        {
          name: 'Not in Process',
          data: notInProcessItems
        }, {
          name: 'In Process',
          data: inProcessItems
        }, {
          name: 'Percentile',
          data: [],
          yAxis: 1,
          showInLegend: false
        }
      ];
      return this.visualizationData = {
        series: series,
        histogramResults: histogramResults,
        histogramCategories: histogramCategories,
        histogramData: histogramData,
        startMilliseconds: startMilliseconds,
        asOfMilliseconds: asOfMilliseconds
      };
    };

    return TIPVisualizer;

  })(VisualizerBase);

  this.TIPVisualizer = TIPVisualizer;

}).call(this);
